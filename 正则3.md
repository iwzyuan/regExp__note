##什么叫正则？

> 1.正则就是一个规则，用来处理字符串的一个规则（正则就是用来处理字符串的）
> 1) 匹配：判断一个字符串是否符合我们制定的规则-> test:reg.test()
> 2) 捕获：把字符串中符合我们正则规则的内容捕捉到->exec:reg.exec(str)
> 
> 2.如何创建一个正则？
> 字面量方式：
> var reg = /\d/;
> 实例创建方式：
> var reg = new RegExp("")
> 正则的两种创建方式是有区别的
> 
> 
> 
> 正则元字符：每一个正则表达式都是由元字符和修饰符组成的
> [元字符] -> 在//之间具有意义的一些字符
> 1. 具有特殊意义的元字符

> - \ : 转义字符，转义后面字符所代表的含义
> - ^ : 以某一个元字符开始
> - $ : 以某一个元字符结尾
> - . : 除了\n以外的任意字符
> - \n : 匹配一个换行符
> - ）：分组-> 把一个大正则本身划分为几个小的正则
> - x|y : x或者y中的一个
> - [xyz] ：x或者y或者z中的一个
> - [^xyz] : 除了三个以外的任何一个字符
> - [a-z] ： a-z之间的任何一个字符
> - [^a-z] : 除了a-z之间的任何一个字符
> - \d : 一个0-9之间的数字  \D：除了0-9之间的数字以外的任何字符
> - \b : 匹配一个边界符
> - \w : 数字字母下划线中的任意一个字符[0-9a-zA-Z_]
> - \s : 匹配一个空白字符 空格、一个制表符、换页符...

```javascript
var reg = /\d/ //没加^和$ 意思是包含
var reg2 = /^\d$/ //加了的话，意思是中间只能是一个数字
```

> 2. 代表出现次数的量词元字符
> * ：出现零到多次
> + ：出现一到多次
> ？：出现零次或者一次
> {n} ： 出现n次
> {n,} : 出现n到多次
> {n,m} ： 出现n到m次

```javascript
//[] 
//1. 在中括号中出现的所有字符都是代表本身意思的字符（没有特殊含义）
//2. 中括号不识别两位数
var reg = /^[12-68]$/ //=>代表1|2-6|8其中一个
//（）
//3分组的作用一：改变x|y的默认的优先级

var reg = /^18|19$/
//18,19,181,189,119,1819..
var reg = /^(18|19)$/

//1. 有效数字的正则 （正数，负数、小数、零）
//1）可以出现小数，也可以不出现，一旦出现点后面必须跟一位或者多位数字
//2）最开始可能有+/-也可以没有
//3）整数部分一位数可以是0-9之间的一个，多位数不能以0开头

var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/

//2. 18-65之间 18-19  20-59  60-65
var reg = /^(1[8-9]|[2-5]\d|6[0-5])$/

//3.验证邮箱的正则（简版）
//左边：数字字母下划线 中间：@  右边：[0-9a-zA-Z]+\.[a-zA-Z]{1,2}

var emailReg = /^[\w\.-]+@[a-zA-Z0-9]+(\.[a-zA-Z]{2,4}){1,2}$/ 

61 0111 199509092016
``` 
###字面量创建与实例创建的区别

```javascript
    var name = 'wu';
    //在字面量方式中我们//之间包起来的内容都是元字符，有的具有特殊的意义，大部分都是代表本身含义的普通元字符
    var reg1 = /\d+"+name+"\d+/g;
    reg.test("2wu2") //=> false
    reg.test("2""""wueeeee2")//=>true
    
    //对于这样的需求我们只能使用实例创建的方式
    var reg2 = new RegExp("\\d"+name+"\\d","g");
    reg.test("1wu1") //=> true
    
    //字面量方式和实例创建的方式的区别？
    //1）字面量方式中出现的一切都是元字符，所以不能进行变量值的拼接，而实例创建的方式是可以的
    //2） 字面量方式中直接写\d就可以，而在实例中需要把它转义

```

###正则的捕获（分组）
```javascript
//exec-正则的捕获
//每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功的，捕获的结果是null；只有匹配的内容我们才能捕获到
//捕获的内容格式
//1） 捕获到的内容是一个数组，数组中的第一项是当前正则捕获的内容（index：捕获的内容在字符串开始的索引位置。input：捕获的原始字符串）
//lastIndex : 是正则每一次捕获在字符串中开始查找的位置
var reg = /\d+/
var str = 'wu2017haha2018'
reg.exec(str); //-> 2015,lastIndex:0
reg.exec(str); //-> 2015,lastIndex:0
//2）正则捕获的特点
// 懒惰性->每一次执行exec只捕获第一个匹配的内容，再不进行任何处理，多次执行捕获，捕获的还是第一个匹配内容
//3)如何解决懒惰性？在正则的末尾加一个修饰符“g”
//修饰符：i，m，g
//global(g):全局匹配
//ignoreCase(i) : 忽略大小写
//multiline(m) : 多行匹配

//加了g原理：加了全局修饰符g，正则每一次捕获结束后，我们的lastIndex的值都变成了最新的值，下次捕获从最新的位置开始捕获
var reg = /\d+/g;
var str = 'wu1017wu2019';
reg.exec(str);//->1017 lastIndex:0
reg.exec(str);//->2019 lastIndex:5

//一次得到所有的匹配内容
var reg = /\d+/g;
var str = 'wu1017wu2019ha516';
var ary = [];
var res = reg.exec(str);
while(res){
    ary.push(res[0]);
    res = reg.exec(str);
}
console.log(ary); //=> ["1017","2019","516"]

//贪婪性：正则的每一次捕获都是按照匹配最长的结果捕获的，例如：2符合正则|2015也符合，我们默认捕获的是2015
var reg = /\d+/g;
var str = 'wu1017wu2019ha516';
var res = reg.exec(str);//=> 2015

//如何解决正则的贪婪性 -> 在量词元字符后面添加一个问号即可
//?在正则中有很多作用
//1）放在一个普通的元字符后面代表出现0-1次/\d?/数字可能出现也可能不出现
//2）放在一个量词的元字符后面是取消捕获时的贪婪性
//3）（?:） 在分组中?:的意思是只匹配不捕获
var reg = /\d+?/g;
var str = 'wu1017wu2019ha516'; 
var res = reg.exec(str);//=> 2

//字符串中的match方法-> 把所有和正则匹配的字符都获取到
var reg = /\d+?/g;
var str = 'wu1017wu2019ha516'; 
var ary = str.match(reg); //=>一次得到

//虽然match在当前的情况下match比我们的exec更加的简洁一些，但是match中存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则匹配的内容，而对于小正则捕获的内容是无法获取的

```

###正则分组

> - 改变优先级
> - 分组引用
> - 分组捕获：正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到

```javascript
//\2代表和第二个分组出现一模一样的内容
//\1 代表和第二个分组一摸一样的内容
//一摸一样：和对应的分组中的内容的值都要一样
var reg = /^(\w)\1(\w)\2$/
reg.test("zzff");

//在分组中?:的意思是只匹配不捕获
   var str =  '610111199509092016';
   var reg = /(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(\d|X)/g
   console.log(reg.exec(str)); //=>ary = ["610111199509092016", "61", "0111", "1995", "09", "09", "20", "1", "6", index: 0, input: "610111199509092016", groups: undefined]
//ary[0] -> 大正则捕获的内容
//ary[1] -> 第一个分组捕获的内容

//在reg有g时，match分组失效
 var str =  '610111199509092016';
   var reg = /(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(\d|X)/
str.match(reg) //ary = ["610111199509092016", "61", "0111", "1995", "09", "09", "20", "1", "6", index: 0,...]
 var str =  '610111199509092016';
   var reg = /(\d{2})(\d{4})(\d{4})(\d{2})(\d{2})(?:\d{2})(\d)(\d|X)/g
str.match(reg) //ary = ["610111199509092016"]
```


###replace

> replace：把原有的字符替换成新的字符，在不使用正则的情况下，每当执行一次只能替换一个字符

```javascript
var str = "wu123wu456"
str.replace("wu",'wuzhongyuan').replace('wu','wuzhongyuan');
str -> 'wuzhongyuanzhongyuanwu456'

str = str.replace(/wu/g,"wuzhongyuan") //=> 可以实现
//replace第一项的值是一个正则它的实现原理
//首先我们和exec捕获一样，把所有和我们正则匹配的都捕获到，然后把捕获的内容替换成我们需要替换的新内容
//  /wu/g 按照这个正则str中所有可以匹配的捕获到，然后替换掉


var str = "wu123wu456"
str = str.replace(/wu/g,function (){
    console.log(arguments)
    console.log('ok');//执行两次
    return 'wuzhongyuan'
})
//第二个参数换成一个函数 
var str = "wu123wu456"
    var reg = /wu/g;
    console.log(reg.exec(str));//["wu", index: 0, input: "wu123wu456"...]
    console.log(reg.exec(str));//["wu", index: 5, input: "wu123wu456"...]
    str = str.replace(reg,function (){
        console.log(arguments);//["wu", 0, "wu123wu456"... ]  ["wu", 5, "wu123wu456"...]
        console.log('ok');//执行两次
        return 'wuzhongyuan'
    })
    //将replace第二个参数替换成一个函数
    //1. 匿名函数执行多少次，取决于正则能在字符串中捕获多少次->正则捕获两次，所以我们匿名函数也执行两次
    //2. 每一次执行匿名函数，里面传递的参数值arguments和我们自己通过exec捕获到的结果是非常类似的（即使正则有分组，我们也同样可以通过arguments获取到分组的内容）
    //3. return 返回的是什么，就相当于把当前这一次大正则捕获的内容替换成你返回的内容
    
 var str = '123453454';
var ary = ['一'，'二','三','四'...]
str.replace(/\d+?/g,function () {
    return ary[arguments[0]];
})
```



